## 性能优化
- 分析
1. 排队时间过长
在 http1 中浏览器对一个域名有6个连接的限制，如果6个连接都在忙碌中，后面的请求就要进入排队状态，基于此，我们可以把资源放在一个站点下的多个域名下，每个域名都有6个连接，三个域名就有18个连接了，这个叫域名分片，在http2中，因为始终只有一个连接，所以也就不存在这一说了
2. 首字节时间过久
这段时间都是在服务器那边的，可能是服务器数据处理时间过长
也可能是网络原因
请求头带上了多余的用户信息，比如cookie，服务器在接收到之后要一一进行处理，这样就增加了服务器处理的时长，对于cookie可以使用cookie隔离技术，比如一些静态资源是不需要携带cookie的，那么就可以把这些静态资源放在不同的域名下，因为cookie是不允许跨域携带的。在 http2 中使用了头部压缩的技术：在客户端和服务端之间建立了一张首部表，存放首部的信息，两边都会对这个表进行更新，对于相同的数据不会再重复发送，
- 优化手段
1. 缓存：合理利用 http 缓存
2. 网络： cdn
3. 包体积：路由的按需加载，gzip 压缩，第三方资源的按需加载
4. 防止内存泄漏
5. 代码层面：图片懒加载，长列表的优化
6. ssr 服务端渲染，服务端直接返回模板资源
7. 预加载

### CDN：内容分发网络

## 内存泄漏
1. 全局变量
2. 闭包
3. 没有清除的定时器
4. console.log
5. 引用的dom节点，变量引用了dom节点，之后这个 dom 被删除了，因为变量还在引用，所以这个dom占据的内存得不到释放

## 错误监控
- web 端的 js 错误
window.onerror 事件监控
window.addEventListener监听 unhandleRejection 事件捕获 promise 的错误
请求错误在封装请求的时候对错误的状态码统一监听处理
- node 端的
process.on 监听 uncaughtException 处理错误
process.on 监听 unhandleRejection 处理异步错误（被reject，但是没有reject处理器

### 埋点监控 SDK 设计
1. 首先确定监控什么
- 页面性能
- 用户行为
- 错误监控

2. 怎么监控
    1. 页面性能
        - 首先如何得到性能数据
            使用 PerformanceNavigationTiming 这个 API 可以获取到一些关键事件的时间点，比如页面跳转或者重定向、页面开始请求资源，dns 解析，tcp 连接、服务器返回第一个字节的时间、首次内容绘制，dom加载完成等等一系列事件的时间点，通过计算这些时间点，得出一些关键指标，比如首屏时间，白屏时间，TTI等等
        - 然后如何发送给服务器
            1. 使用image 标签的 src 属性，不受跨域限制，
            2. 使用navgatior.sendBeacon,需要判断浏览器兼容性，他是异步执行的
        - 什么时机获取
            性能数据肯定是必须要用的，所以直接在 sdk 初始化的时候就去获取并发送
    2. 用户行为
        - 一些交互行为，比如点击事件，需要开发者自行调用，提供一个 API，接收一个事件类型和其他的一些自定义的参数
        - 一些隐形的行为，可以自行获取不需要开发者关注的，比如 PV、UV、用户在页面的停留时长、用户的设备信息等等，这些数据是否需要获取可以由开发者决定，在初始化 SDK 的时候提供一个配置参数
    3. 错误监控
        1. js 错误
            - window.error 可以捕获同步代码的错误
            - window.unhandleRejection 捕获 promise 内部抛出的错误
        2. 请求错误
            劫持 xhr 请求，做统一处理，对错误的状态码做统一的处理
        3. 错误上报
            批量上报，利用浏览器空余时间上报，requestIdleCallback

TTI：完全可交互时长。
从页面加载开始，到页面可快速响应用户操作所需要的时间
计算方式
从 FCP 开始，沿着时间轴正向搜索至少为 5s 的安静窗口，安静窗口的定义为，没有长任务（执行时间超过 50ms 的）且不超过两个以上的 get 请求
然后从安静窗口反向搜索最后一个长任务，如果没有，则以 FCP 的时间为准
TTI 的时间就是从 FCP 开始到安静窗口前最后一个长任务结束的时间
        