// 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

//        4
//      /   \
//    2       6
//   / \    /  \
//  1   3  5    7
/**
 * 后序遍历是左 右 根 的 顺序
 * 上面这颗二叉搜索树 他的后序遍历数组是 [1,3,2,5,7,6,4]
 * 验证的整体思路就是 把这个数组按左右子树划分 直至划分到叶子节点
 * 划分的思路
 *  因为右子树的值都比左子树的值以及最后一个数字也就是根节点都是大的  5 7 6 > 1 3 2 > 4 所以找到右子树最左边的节点的值就可以划分左右子树
 *  右子树最左边的值就是数组中第一个比根节点大的值 在这就是 5
 */

function verifyPostorder(list) {
    // i j 代表要判断数组的左右边界 j 位置的数字就是根节点
    const recur = (i, j) => {
        // 当 i j 相遇就说明划分到了叶子节点 可直接返回true
        if (i >= j) return true
        // 设置一个指针从左边界开始
        let p = i
        // 指针向左移 找一个比根节点大的值 就是右子树的最左边的值
        while (list[p] < list[j]) p++
        // 记录右子树最左边值的位置
        let m = p
        // 继续向右移 到最后一个数字也就是根节点之前的值都应该是比根节点的值大的  所以正确的话会一直到最后一个数字 与 j相遇
        while (list[p] > list[j]) p++
        // 当 p 和 j 也就是根节点相遇了说明是正确的  按照之前划分的左右子树 再递归分别对其进行判断  这三者都正确的话 才是正确 所以用 && 连接
        return p === j && recur(i, m - 1) && recur(m, j - 1)
    }

    return recur(0, list.length - 1)
}