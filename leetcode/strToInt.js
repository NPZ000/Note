// 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
// 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
// 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
// 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
// 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
// 在任何情况下，若函数不能进行有效的转换时，请返回 0。
// 说明：
// 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

function strToInt(str) {
    // 去除首尾空格
    const s = str.trim()
    if (!s) return 0
    // 从第几位开始读
    let index = 1,
        // 负数还是正数的标志
        sign = 1,
        res = 0
    const max = (2 ** 31) - 1, // 最大数
          min = -(2 ** 31),    // 最小数
          bndry = Math.floor(max / 10) // 最大数的。。。。
    // 如果第一位是负号 就修改标志 sign
    if (s[0] === '-') {
        sign = -1
    // 如果第一位不是正号 也不是符号 就说明有可能是正数 所以从第 0 位开始读
    } else if (s[0] !== '+') {
        index = 0
    }

    for (let j = index; j < s.length; j++) {
        // 碰到不是数字的直接跳出循环
        if (!/[0-9]/.test(s[j])) {
            break
        }
        // 如果当前结果已经大于 bndry 了，再加的话肯定越界，比如当前结果是 14，最大值是138，14再加个最小的0，140 也比 138 大
        // 或者等于 bndry 并且当前要加的位数 大于 7 ，边界值的最有一位是8，再加的话肯定越界或者正好是边界
        // 这两种情况直接返回边界值，根据 sign 的值判断是要返回最大值还是最小值
        if (res > bndry || (res == bndry && s[j] > 7)) {
            return sign > 0 ? max : min
        }
        // 把当前位的数字加到结果上
        res = res * 10 + Number(s[j])
    }
    // 最后记得要乘正负号的标志
    return res * sign
}
