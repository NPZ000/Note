// 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
/**
 * 
 * @param {原始数组} nums 
 * @returns 只出现一次的数字
 * 思路
 * 把所有的数字的每个二进制位上的值加起来 然后都分别 % 3，得到每个二进制位上的值 这个二进制数转成十进制 就是那个只出现一次的数字
 * [3, 3, 3, 5]
 *   0 0 1 1
 *   0 0 1 1
 *   0 0 1 1
 *   0 1 0 1
 *   每个位上都加起来
 *   0 1 3 4
 *   再分别 % 3
 *   0 1 0 1 = 5
 * 下面用有限状态机的思路解
 * 在计算各个位上的和的时候 值只有三种状态 即对 3 求余 结果为 0 1 2
 * 状态变化过程为
 *  若输入 1  0 -> 1 -> 2 然后往复
 *  若输入 0 则状态不变
 * 二进制只有 0 1，所以这三种状态表示为 00 01 10 
 * 每个状态上第一位为 two 第二位为 one
 * 然后现在的状态转移过程 就是 
 *  输入 1 为 00 -> 01 -> 10 
 *  输入 0 则状态不变
 * 这个输入的值可以理解为就是在对各个位求和过程中的下一个值
 * 这个状态转移过程用表格表示
 *      n  two  one ->  tow  one
 *      0  0    0       0    0
 *      0  0    1       0    1
 *      0  1    0       1    0
 *      1  0    0       0    1
 *      1  0    1       1    0
 *      1  1    0       0    0
 * 
 * 对着这个表再来看如何求 one 和 two
 * one 的求值
 * if two = 0
 *   if n = 0
 *      one = one
 *   if n = 1
 *      one = ~one
 * if two = 1
 *   one = 0
 * 
 * 以上过程用 异或 ^ 简化
 * if two = 0
 *   one = one ^ n
 * if two = 1
 *   one = 0
 * 
 * 再用 与 & 简化
 * one = one ^ n & ~two
 * 
 * 如何证明以上两个简化是对的
 * x ^ 0 = x  0 ^ 0 = 0  1 ^ 0 = 1 所以还是 x
 * x ^ 1 = ~x  1 ^ 1 = 0  0 ^ 1 = 1 所以结果是 ~x
 * 把异或右边的值当成上面输入的 n 就可以得到第一步的简化
 * x & 0 = 0  不管是 0 还是 1，与 0 都是 0
 * x & 1 = x   0 & 1 = 1  1 & 1 = 1, 所以还是 x
 * 同理把 two 代入与右边的值 就可以得到第二步的简化
 * 
 * 以上就是 one 的计算过程
 * 然后再看 two 的计算过程 two 的计算要在 one 的计算结果的基础上
 * 先来看一下计算 one 状态的变化前后对比  注意这里是只有 one 变了 two 还没变
 * change after
 *  00 01 10
 * chang before
 *  01 00 10
 * 现在把 two 和 one 的位置交换
 * 10 00 01
 * 调换一下顺序
 * 00 01 10
 * 可以看到还是初始的状态
 * 现在每个状态的 one 其实就是原来的 two , 那我们再来计算现在 one 也就是计算原来的 two 了
 * 所以 two 的计算过程就可以复刻 one 的计算过程
 * two = two ^ n & ~one
 * 
 * 以上所有是单独一位的计算过程，而每一位的计算都是一样的，所以我们可以直接遍历源数组，对每一个元素都应用以上这个计算步骤，
 * 遍历完之后，各二进制位的状态就都处于 00 或者 01 两者之间，具体是哪个取决于那个只出现一次数字的各个二进制位上是 0 还是 1
 * 可以看到这两个状态的 two 都是 0，所以我们就可以不看 two，只看 one ，因此我们只返回 one 就可以了
 */
var singleNumber = function(nums) {
    let ones = 0, twos = 0
    for (const num of nums) {
        ones = (ones ^ num) & ~twos
        twos = (twos ^ num) & ~ones
    }
    return ones
};
singleNumber([3,3,3,5])