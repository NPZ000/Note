// 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
// 最小的丑数是 1

/**
 * 后面的丑数是由前面的某一个丑数 *2 || *3 || *5 得来的
 * 比如丑数序列 2 3 4 5 6 8 9 此中的 6 是由前面的 2 * 3 得来的,
 * 我们不知道第 n 个丑数是由前面的第几个丑数乘的 2 3 5 三个中的哪一个得来的
 * 但是我们知道第 n 个丑数一定是第 n - 1 个丑数之后最小的那个丑数
 * 怎么保证这个最小呢 就是把前面的丑数都挨个乘一遍 2 3 5，然后取最小的那个
 * 很明显 如果我们每次求第 n 个丑数的时候都这么干的话 肯定是有大量没意义的操作
 * 所以我们这里用动态规划 把之前的结果都保存起来
 * 需要用到三个指针 a b c
 * 我们只需要求 a b c 指针对应的数字分别乘了 2 3 5 之后那个最小的数字就行了 因为他们之前的都已经求过了
 * 比如从第一个丑数 1 开始，现在 a b c 都指向 1 ，1 分别乘 2 3 5，取最小的 2，就是下一个丑数，这个 2 是 a 指针的数字求出来的
 * 所以 a 向前走一步 这里要注意的是可能下一个丑数能同时被第 a 个丑数和第 b 个丑数求出来 那么此时 a 和 b 都应该向前走一步
 * 所以不能用if else
 */

function uglyNumber(n) {
    const dp = [1]
    let a = 0, b = 0, c = 0
    for (let i = 1; i < n; i++) {
        const p1 = dp[a] * 2, p2 = dp[b] * 3, p3 = dp[c] * 5
        console.log(a, b, c, p1)
        dp[i] = Math.min(p1, p2, p3)
        dp[i] === p1 && a++
        dp[i] === p2 && b++
        dp[i] === p3 && c++
    }
    console.log(dp)
    return dp[n - 1]
}
uglyNumber(11)