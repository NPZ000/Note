# 浏览器的进程架构
- 线程 & 进程
    每个应用程序都会开一个进程，用来存放代码/数据/一个执行主任务的线程，一个进程就是一个程序的运行实例，在一个进程之下，会有多个线程，进程下的线程可以共享进程的数据，每个进程之间都是隔离的，进程关闭之后，会回收它所占用的空间
- 早期的单进程架构
浏览器运行在一个进程内，然后每个模块运行在一个线程内
    - 不稳定：插件或者渲染引擎的崩溃都会引起整个浏览的崩溃
    - 不流畅：所有页面的渲染都是在一个线程下，某个页面的长时间渲染会独占整个线程，从而影响到其他页面
    - 不安全：插件可以读取到系统的任意资源，脚本代码可以获取到系统的权限
- 当前的多进程架构
    1. 浏览器的主进程：负责页面显示，用户交互，子进程的管理
    2. 渲染进程：将 HTML CSS JS 渲染成页面，会给每个 tab 标签页都开一个渲染进程，所以就算某个页面挂了，也不会影响到其他页面，并且通过沙箱隔离，使其中的脚本代码无法再获取系统权限。同站点（根域名和协议相同，子域名和端口可能不同）下的标签页面共用一个渲染进程，因为可能同站点下的不同页面之前想搞点什么操作
    3. GPU 进程：用来渲染动画
    4. 网络进程：负责页面的网络资源加载
    5. 插件进程：运行插件
- 未来面向服务的架构
每个模块都作为一个独立的服务，运行在不同的进程内，通过 IPC 进行通信，访问服务需要通过特定的接口

# TCP 如何保证数据完整的到达浏览器
网络中数据是分成小的数据包进行传输的
- 数据如何传输到对方的主机
数据要想在网络中互相传输就需要知道对方的 IP 地址
数据包在网络层需要加上 IP 头，包括自己的 IP 地址和对方的 IP 地址，在传输到对方那里之后，会在网络层解析出 IP 头的数据，剩下的数据交给上层
- 数据到达主机之后，如何交给上层的应用程序
UDP 用户数据包协议，UDP 中最重要的就是端口号，每个应用程序都会绑定一个端口号，这样 UDP 就知道要交给哪个应用程序
在网络层之上还有一层传输层，UDP 头的数据会在这里被加上和解析
UDP 不保证数据的完整性，也没有重发机制，但是传输速度很快
- TCP 把数据完整的交给应用程序
    对于一些对数据的完整性有严格要求的就需要使用 TCP
    TCP 是面向连接的 基于字节流的传输层通信协议，对于数据包丢失的情况具备重传机制，引入了数据包排序机制；TCP 头除了源端口号和目标端口号之外还需要用于排列的序号
    - TCP连接
        1. 建立连接，三次握手，确认建立的连接
        2. 传输数据阶段，接收端会对每个数据包进行确认操作，也就是说每收到一个数据包，都会回复发送端一个 ACK，如果发送端长时间没有接收到接收端的 ACK，就会触发重传操作，接收端接收完数据之后，会对其进行排序
        3. 断开连接阶段，四次挥手

# HTTP 请求流程
1. DNS 解析，拿到 IP 之后还要准备端口号， http 协议默认是 80 端口，
2. 等待 TCP 队列，浏览器对同一个域名限制 6 个 TCP 连接，如果当前已经有 6 个请求，之后的请求会暂时进入排队等待状态
    关于复用：
        1. 如果之前有保持长连接的 tcp 连接
            空闲的 -> 复用
            不空闲 -> 重新开一个（当前连接数小于6
3. 建立 TCP 连接
4. 发送 HTTP 请求：发送请求行（请求方法/请求地址/http版本协议），还有请求头和请求体，返回请求（响应行：http 版本协议，状态码/相应头/响应体）
5. 断开连接：如果之前的请求头设置了长连接（connection: Keep-Alive），则不会断开连接

# 从输入 URL 到页面展示
（谷歌浏览器，不是关键字的情况）
1. 地址栏会根据规则，给地址加上协议，合成为完整的 url，比如 www.baidu.com -> http://www.baidu.com。如果之前有旧的页面，浏览器还会给她一次执行 beforeunload 事件的机会，让他用来清除数据，释放内存，或者询问客户是否要离开，可以取消导航，让浏览器不再执行后续的操作，如果没有执行这次事件，标签页上的图标就会进入loading状态
2. URL 请求过程：浏览器进程拿到 URL 然后通过进程间通信（IPC）把 URL 交给网络进程，然后网络进程发起请求，首先就是 dns 解析，然后建立 tcp 连接，发送请求，服务器返回信息给网络进程，
    - 重定向：如果返回的状态码是 301 或者 302，会读取location字段的地址，重新发起新的请求，重头开始，有一些网站会设置重定向把 http 的请求重定向到 https
3. 响应数据处理：浏览器通过响应头的 content - type的值如果是 text/html，就知道返回的 html 格式的数据
4. 准备渲染进程：默认情况下每个Tab页面都会新开一个渲染进程，如果是同站点（协议和域名相同）下的又新开的页面，那么就会复用父页面的渲染进程
5. 提交文档：指的是浏览器进程让网络进程把接收到的数据交给渲染进程
    - 网络进程接收到数据之后会通知浏览器进程，然后浏览器进程再向渲染进程发送提交文档的消息
    - 渲染进程接收到提交文档的消息之后，会和网络进程建立传输数据的管道
    - 文档数据传输完成之后，渲染进程会返回确认提交的消息给浏览器进程
    - 浏览器进程收到确认的信息之后，会更新浏览器界面状态，
6. 渲染进程开始渲染

# 渲染阶段
- 构建 DOM 树：将 HTML 转换成浏览器可以理解的结构
- 样式计算：
    1. 计算每个节点的样式，将 CSS 转换为 styleSheet，
    2. 转换样式表中的属性值，使其标准化，比如将 red 转换为 rgb 格式
    3. 计算每个节点的具体样式，涉及到继承规则和层叠规则
        - 继承规则： 子节点会继承父节点的一些样式，比如 font-size,color等，
        - 层叠规则
- 布局阶段：计算 DOM 树中可见元素的几何位置 
    1. 创建布局树：在原来的 dom 树的基础上，额外的构建一颗只包含可见元素的的布局树，忽略掉比如header元素和设置了 display: none 的元素
    2. 计算每个元素的几何位置，保存在布局树中
- 分层
因为页面中经常会有很多复杂的情况，比如页面滚动，或者使用z-index做层叠上下文，渲染引擎会为这些特殊的节点生成图层，并不是每一个节点都有对应的图层，如果没有那他就从属于父节点的图层，什么情况下会为节点生成图层呢？
    - 拥有层叠上下文属性的元素，如设置了z-index/opcity/css滤镜等属性的元素
    - 需要裁剪的情况，盒子里的内容超出了盒子的大小
- 图层绘制：把一个图层的绘制拆分成很多小的绘制指令，然后按顺序组成一个待绘制的列表
- 栅格化
图层绘制之前都是在渲染进程的主线程完成的，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程
通常一个页面很大，但是用户只能看到可视区域的那一部分，所以没必要绘制出所有图层，所以合成线程会将图层划分为图块，然后合成线程会优先把视口附近的图块生成位图，将图块转换成位图的操作就是栅格化
通常栅格化都会使用 GPU 来加速生成，如果使用了 GPU 那么生成位图的操作就会在 GPU 进程内完成
- 合成和显示
栅格化完成之后，合成线程会通知浏览器进程，然后浏览器进程将其页面内容绘制到内存中，再显示到屏幕上

### 分层&合成
- 分层
一个网页由很多个图片叠加在一起，每张图片对应一个图层，将素材分解为多个图层的操作就是分层
- 合成
将图层合并到一起的操作就是合成
- 分块
通常情况下，页面的内容要比屏幕大很多，显示一个页面时，如果等待所有图层都生成完毕，再进行合成的话就会产生一些不必要的开销，也会很耗时，所以合成线程将每个图层分割长若干个图块，然后优先绘制视口附近的图块

利用分层技术可对代码进行的优化
提前告诉渲染引擎将要对某个元素进行几何变换或者透明度变换等操作，然后渲染引擎就会单独对该元素生成一个图层，等这些变化发生时，渲染引擎对通过合成线程直接对对应的图层进行操作，
```css
.box {
    will-change: transform,opacity;
}
```

## HTTP/1.1 & HTTP/2
- HTTP/1.1做了哪些优化
1. 增加了持久连接
2. 为每个域名提供了最多6个域名的连接
3. 使用 CDN 实现了域名分片机制
    把资源部署在不同域名的 CDN 下，每个域名都可以有6个连接
HTTP/1.1存在的问题
对于带宽的利用不理想，原因如下：
1. TCP 的慢启动：TCP 刚开始建立连接之后就用一个很慢的速度去发送数据，然后逐渐提升速度，直至到达一个理想的状态，首次渲染页面需要的 HTML、CSS 文件等都在这个阶段请求加载，就会造成体验上的不好
2. 同时开启了多条 TCP 连接，那么这些连接就会竞争固定的带宽：多个连接之间不知道哪些关键资源需要优先下载
3. 队头阻塞的问题
同一个 TCP 连接在同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求都得处于等待状态

- HTTP/2
1. 多路复用
    只使用一个 TCP 连接来传输数据，所有请求可以同时并行发送，每个请求都会经过一个二进制分帧层，数据在这里会转换为一个个带有请求ID编号的帧，然后发送给服务端，服务端接收到之后会根据编号重新组装
2. 可以设置请求的优先级，服务器会优先处理高优先级的请求
3. 服务器推送
    服务器会主动推动资源到客户端
3. 头部压缩
    对于请求头，每次只发送新增的或者修改的部分，对于相同的数据不会重复发送
ps: 只使用一个 tcp 连接，只需要一次 tcp 的慢启动，规避了多个连接竞争带宽的问题

- HTTP/3
HTTP/2 依然存在的问题
- 因为 HTTP2 依旧是依赖的 TCP 的，而 TCP 存在队头阻塞的问题：传输的数据会被拆分成若个数据包在 TCP 中间传输，如果在传输的过程中发生了丢包的现象，那么整个 TCP 连接就会处于暂停状态，直至丢失的包被重新传输过来。在 HTTP2 中，多个请求是跑在一个 TCP 连接中的，如果某个数据流发生了丢包的现象，那么就会阻塞该连接中的所有请求，随着丢包率的增加，传输效率会越来越差
- TCP 建立连接的延时
    连接时握手的时间和进行 TLS 连接的耗时
- TCP 协议的僵化
即使知道 TCP 连接的问题，因为网络连接中间存在各种物理设备，所以不好去修改 TCP 协议
HTTP/3的改进
**QUIC协议**
在 UDP 的基础上，
1. 实现了类似 TCP 的流量控制，传输可靠性的功能，包括数据包重传等；
2. 集成了 TLS 加密功能；
3. 同样具有多路复用功能：和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流，这样就不会存在 TCP 的队头阻塞问题了
4.  实现了快速握手功能

## 同源策略
域名 协议 端口一致
- dom 层面
同源的页面可以互相操作dom，window.opener:返回打开当前窗口的那个窗口的引用，借此就可以操作父级页面的dom
```js
let pdom = window.opener.document
pdom.body.style.display = 'none'
```
- 数据层面
同样可以借助 opener 来获取父级页面的cookie等数据
- 网络层面
不同源的域名不可以互相发送请求

**浏览器开放的口子**
- 可以引入任意的资源，也就是我们常说的script标签不受同源策略的限制，但是容易受到xss的攻击，所以需要用 csp 来限制，也就是让服务器来决定可以加载哪些源的资源，可以执行哪些 js 脚本
- 跨域资源共享： cors
- 跨文档消息机制：window.postMessage

### XSS
跨站脚本攻击，向 HTML 文件或者 DOM 中注入恶意的脚本，从而在用户浏览页面时执行脚本对用户实施攻击
1. 可以窃取用户信息，cookie
2. 监听用户行为，addEventListener监听键盘事件
3. 通过修改dom伪造假的登陆窗口，从而用来欺骗用户的的密码等信息
4. 生成浮窗广告

- 存储型 XSS 攻击
通过站点漏洞将恶意脚本存储到网站数据库中，之后连同恶意脚本和资源一起返回给用户，接着恶意脚本被加载后就会自动执行，
    比如： 用户在提交表单时，提交了一段js代码，然后服务端将其存储在数据库，之后这段数据被返回到客户端时，那段js代码就会在页面中执行了
- 反射型 XSS 攻击
一般是把恶意的脚本代码拼接在query中，服务端在接收到之后，连同query中的参数和资源一同再返回给客户端，在这个过程中是不会去存储数据库的
- 基于 DOM 的 XSS 攻击
比如通过网络劫持再页面传输过程中修改 HTML 页面内容

**防范 XSS 攻击的手段**
1. 服务器对客户端发送的数据进行过滤和转码
2. 充分利用 CSP：
    - 限制加载其他域的资源文件
    - 禁止向第三方提交数据
    - 禁止执行内连脚本
    - 提供上报机制
3. Httponly
设置此属性，就可以限制js读取cookie

### CSRF
跨站请求伪造：黑客引导用户打开第三方网站，在第三方网站中利用用户的登录状态向目标网站发起请求
举个🌰：用户登陆了 A 网站，在浏览器中保存了 cookie 登陆态，然后在 A 网站中点击了恶意链接跳转到了 B 网站，在 B 网站中悄悄向 A 网站发起了一些请求，这时候浏览器会在这些请求中携带原来保存的那些 cookie ，A 网站的服务器收到请求，看到有 cookie 就会误以为是用户发的真实请求。
**防范手段**
1. 利用 cookie 的 SameSite 属性，设置为 Strict 之后，就会严格禁止第三方站点的请求携带cookie
2. 验证请求的来源站点
    - referer：请求的来源地址
    - origin： 域名信息
    优先判断origin，然后判断referer
3. csrf token
第一次请求会返回客户端一个token，之后每次请求携带这个token，在第三方站点是无法知道这个token的

## 渲染内核与浏览器内核
浏览器主要分为渲染内核与浏览器内核两个部分，浏览器内核包括浏览器主进程，网络进程、GPU进程等，渲染内核就是渲染进程，渲染进程被沙箱隔离，所以在渲染进程内没有操作系统的控制权限，也没有发起网络请求或者和用户交互等权限，这样是为了防止攻击者在渲染进程内部向浏览器发起攻击，
有持久存储（cookie）、网络访问、用户交互这些需求的，渲染进程需要通知到浏览器内核，在浏览器内核完成这些事件之后，再将结果返回给渲染进程

## HTTPS
- 对称加密：用同样的密钥进行加解密，协商密钥容易被获取
- 非对称加密：服务端给客户端一个公钥，自己保留一个私钥，客户端用公钥加密数据，服务端用私钥解密
- 对称加密结合非对称加密：非对称加密交换协商密钥，然后用协商密钥进行对称加密（DNS 劫持，如何保证服务器是可信的）
- CA 验证
验证服务器的身份，首先是服务器去向 CA （一般是中间CA）申请一个证书，服务器向 CA 机构提交自己的信息，公钥，CA 对其认证并颁发给一个数字证书，数字证书包括服务器的自己的信息，公钥，还有 CA 对服务器信息 hash 之后得到的一个摘要然后用私钥对摘要加密得到的一个签名。
在 TLS 的握手过程中，服务器会把自己的证书发给客户端，客户端会验证证书真实性：客户端会用 CA 机构的 hash 方法对证书中服务器的信息得到一个摘要，然后用 CA 的公钥对数字签名进行解密，又得到一个摘要，对比两个摘要，即可验证证书的真实性，到这里还有两个问题，客户端验证的这个 CA 证书其实可能是服务器向中间 CA 申请的，那么如何验证这个中间 CA 的身份呢，客户端又是知道这个中间 CA 的那个 hash 方法和公钥的呢，其实服务器还会给客户端一个叫证书链的东西，证书链中包含了中间 CA 的证书还有他的上级 CA 的证书，然后客户端一般会内置一些顶级 CA 机构的根证书，如果通过证书链可以找到一个对应的根证书，那么就可以认证服务器证书的真实性了。
**HTTPS的握手过程**
1. 客户端向服务器发送一个加密套件列表和一个 client random1
2. 服务端返回一个选择的加密算法 + server random2 + 证书
3. 客户端验证证书，生成一个pre-master，然后用服务器公钥对其加密并发送给服务端
4. 服务端收到pre-master之后，对其解密，然后再加上 random1 + random2 ，根据约定的加密算法对其加密生成一个master-secret，接着发送给客户端，
5. 客户端也使用同样的方法生成一个master-secret，之后就使用这个密钥进行对称加密的密钥

### 渲染进程
假如在 A 页面中点击 a 链接或者代码中有window.open 来打开一个新页面 B，那么这两个页面就是有连接的，如果这俩页面是同一个站点，也就是根域名和协议相同，那么这俩页面就会分配在同一个渲染进程，但是如果在 a 链接上设置了 rel=noopener，那么这俩页面就不存在连接关系也就不会再分配在一个浏览器进程里了
还有就是页面中的 iframe 如果和页面是同一个站点也会分配在一个渲染进程中

## lighthouse
生成性能报告，重点关注几个关键指标
- First contentful paint 首次内容绘制 
    可能 HTML 文件加载的时间过长
- Largest Content Paint 可视区域内可见的最大图像或文本完成渲染的时间，也可以说是首屏全部内容完成加载的时间；可能在渲染的过程中又去加载了 js、css等关键资源
- Time to interactive：TTI，表示页面中所有的元素都达到了可交互的时长，此时页面内容完全显现，js事件全部注册完成，页面可以对用户的交互作出快速响应

## 缓存
- cache-control
max-age: 缓存过期时间
no-cache：可以在客户端缓存资源，但是每次都要去服务端做新鲜度校验，来决定是否获取新资源还是使用本地资源
no-store：不在客户端缓存，永远都去服务端获取资源

## 开启 GPU 加速的方法
- transform: translateZ(0)
- opcity
- will-change