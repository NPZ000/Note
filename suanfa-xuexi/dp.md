* 动态规划学习
# 五步走
1. dp数组的定义，dp[i]的含义
2. 递推公式的确定
3. dp数组的初始化
3. 遍历顺序的确定
4. dp数组的推导，打印数组，看是否与推导的结果一致

# 例题 1
⼀个机器⼈位于⼀个 m x n ⽹格的左上⻆ （起始点在下图中标记为 “Start” ）。
机器⼈每次只能向下或者向右移动⼀步。机器⼈试图达到⽹格的右下⻆（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
示例 1：
输⼊：m = 3, n = 7
输出：28
示例 2：
输⼊：m = 2, n = 3
输出：3
解释： 从左上⻆开始，总共有 3 条路径可以到达右下⻆。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

## 解题步骤
1. dp数组的定义：这里需要一个二维的dp数组，dp[i][j]表示在第i行，第j列的位置有多少条路径，最后dp[m - 1][n - 1]就是到达右下角的结果
2. 递推公式：
    因为只能向右或者向下走，所以到达dp[i][j]，只有从dp[i - 1][j]的位置向下走一步，或者从dp[i][j - 1]的位置向右走一步，所以
    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
3. dp数组的初始化：因为只能向右或者向下，所以dp[i][0]和dp[0][j]的值肯定都是1
4. 遍历顺序的确定；同样的因为只能向右或者向下，所以顺序应该死从左往右走，也就是从前往后
5. 推导结果：看示例2的结果应该是
[ 
    [ 1, 1 ], 
    [ 1, 2 ], 2是由左面的1和上面的1相加得来
    [ 1, 3 ]  3同理
]
```js
function npz(m, n) {
    const dp = Array(m).fill().map(() => Array(n).fill(0))

    for (let i = 0; i < m; i++) dp[i][0] = 1
         
    for (let j = 0; j < n; j++) dp[0][j] = 1
            
    
    console.log(dp)
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    console.log(dp)
    return dp[m - 1][n - 1]
}

npz(3, 2)
```

# 示例题 2
还是上面的路径问题，现在会在grid中放置障碍，grid[i][j] = 1,表示此处有障碍，如果是0表示可以走
1. dp数组定义：和上面的一样，dp[i][j]表示走到当前位置有多少种路径
2. 递推公式：因为有了障碍，所以如果要计算dp[i][j]的值，那这里就一定不能有障碍，所以要在前面版本的基础上加上这个判断
    grid[i][j] === 0 && dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
3. 初始化：如果某处有障碍，那从他后面一直到边界的位置肯定都是走不到的，比如
               🈳    🈳   🌰  🈳   🈳
               🈳    🈳       🈳   🈳
               🈳    🈳   🌰  🈳   🈳
    🌰的位置有障碍，虽然他后面的两个位置都是空的，但是因为只能向右和下走，所以他后面的两个位置就都走不到了，所以值应该都是0
    const dp = Array(m).fill().map(() => Array(n).fill(0))
    如果遇到障碍，就直接终止循环
    for (let i = 0; i < m && grid[i][0] === 0; i++) dp[i][0] = 1   
    for (let j = 0; j < n && grid[0][j] === 0; j++) dp[0][j] = 1
4: 遍历顺序：依然是从前往后
5: 推导： 
🈳   🈳  🈳
🈳   🌰  🈳  
🈳   🈳  🈳
1   1   1
1   0   1
1   1   2
```js
function npz(m, n, grid) {
    const dp = Array(m).fill().map(() => Array(n).fill(0))

    for (let i = 0; i < m && grid[i][0] === 0; i++) dp[i][0] = 1
         
    for (let j = 0; j < n && grid[0][j] === 0; j++) dp[0][j] = 1
            
    
    console.log(dp)
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if (grid[i][j] === 1) continue
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    console.log(dp)
    return dp[m - 1][n - 1]
}
const grid = [
    [0, 0, 0],
    [0, 1, 0],
    [0, 0, 0]
]
npz(3, 3, grid)
```

# 示例题 3
给定⼀个正整数 n，将其拆分为⾄少两个正整数的和，并使这些整数的乘积最⼤化。 返回你可以获得的最⼤乘积。
示例 1:
输⼊: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:
输⼊: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不⼩于 2 且不⼤于 58。
1. dp数组的定义：dp[i]表示数字为i时最少拆成两个可以获得的最大乘机
2. 递推公式：最简单的拆 dp[i] = j * (i - j),其中 1 < j < i, 因为可以拆多个，所以再把i - j分解，按照dp[i]的定义，再分解其实就是dp[i - j], j 不用再拆，因为是从1开始算的，在算dp[i - j]的时候，就会算到。要得到最大的乘积，其实就是拆一下和继续拆取最大值，所以公式为
    dp[i] = max(dp[i], j * (i - j), j * dp[i - j])
因为要取最大值，当然还要和dp[i]比较一下，乍一看可能会觉得有问题，这里是在算dp[i]的结果，为什么就已经把他放进去比较了，这里是需要两层循环的，外层循环是固定i的值，内层循环是当i值固定的时候，j为不同值的结果，内循环第一次的时候，dp[i]确实还没被计算出来，所以需要在初始化的时候就把每个位置先写为0，内循环第二次往后，dp[i]就有值了，也必须要参与比较j为不同值时的最大结果

3. 初始化：题目说了n最小是2，2的结果是1，所以直接从2开始，dp[2] = 1
4. 遍历顺序： 从前往后
5. 推导结果： 2 -> 1
            3 -> 2
            4 -> 4
```js
function npz(n) {
    /**
     * 什么时候必须用 0 填充？
        当动态规划满足以下条件时，必须用 0 初始化数组：

        状态转移中包含 Math.max 或累加操作
            若运算可能依赖未显式赋值的初始值，需要用 0 提供数值类型的安全起点。
        无法确定所有状态的默认值时
            默认 0 是一个合理的占位符，保证所有 dp[i] 在递推前有有效初始值。
     */
    // 必须全部初始为0，后面会用到尚未计算到的位置，比如第一次循环的dp[i],这里不用0，就会是undefined,就会导致max计算的结果是NaN
    // 还有注意数组的长度应该是n+1，因为遍历的时候是按第一个数字是1处理的
    const dp = Array(n + 1).fill(0) 
    dp[2] = 1
    for (let i = 3; i <= n; i++) {
        for (let j = 1; j < i; j++) {
            console.log(dp[i])
            dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j])
        }
    }
    console.log(dp)
    return dp[n]
}
```

# 示例题 4 
给定⼀个整数 n，求以 1 ... n 为节点组成的⼆叉搜索树有多少种？
二叉搜索树：根节点左边的数都比根节点小，根节点右边的都比节点的大，天然复合二分查找的特性，搜索快，所以叫搜索树
     2
   1   3

               4
            2     3
         1
                                2
                             1     4
                                 3
1. dp数组定义：dp[i]表示，从1到i的节点的组成的二叉树的数量，也可以说以1到n为节点，组成的搜索树的数量，举例：给定3，dp[3] = 以1为节点的数量 + 以2为节点的数量 + 以 3 为节点的数量
2. 递推公式：先考虑以单个节点i的搜索树数量有多少，根据搜索树的特性，左边的节点都比i小，所以左子树的节点有1 -> i - 1， 搜索树组合数量定义为dp[i - 1],同理，右子树的节点有i + 1 -> n, 搜索树组合定义为dp[n - i], 再考虑左右子树的构成都是独立的，意思就是不管左边的是什么样子，都不影响右边的，假设左子树一共有a种组合，右子树有b种组合，那么以i为节点组成的搜索树的组合数量就是a * b，其实就是笛卡尔积的计算，那么以i为节点的搜索树组合就等于，dp[i - 1] * dp[n - i]，所以递推公式就是
 dp[n] = n∑i=1 dp[i - 1] * dp[n - i]  
3. 初始化dp数组，空节点也算是一个搜索树，所以dp[0] = 1，这个初始化很关键，因为在计算的过程中会有无子树的场景，如果设置为0，就会导致计算结果的错误，比如dp[1] = dp[0] * dp[0] = 0
4. 遍历顺序：后面的值会依赖前面的，所以从前往后，
5. 结果打印 dp[1] = 1, dp[2] = 2 dp[3] = 6
```js
function npz(n) {
    // 这里也必须都填充0 因为dp[i]在第一轮循环中会参与计算
    const dp = Array(n + 1).fill(0)
    dp[0] = 1
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= i; j++) {  
            dp[i] += dp[j - 1] * dp[i - j]
        }
    }
    console.log(dp)
    return dp[n]
}
```

# 示例题 5
有n件物品和⼀个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能
⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。
背包容量为4
        重量 价值
物品0     1  15
物品1     3  20
物品2     4  30
1. dp数组定义：dp[i][j]表示前i个物品，容量为j时，能放下的物品的最大价值
2. 递推公式：在选取物品时，在遍历到第i个物品，容量为j时，有两种情况：第i个物品能放进去或者放不进去，注意这里判断的是容量j大于第i个物品的重量，就是能放进去
    1. 当前物品放不进去，那么dp[i][j] = dp[i - 1][j]
    2. 当前物品还能放进去，再分为两种情况：不放进去或者放进去
        - 不放进去
        那么当前的最大值就还是选取上一个物品时容量为j的最大值，也就是dp[i - 1][j]
        - 放进去
        既然要放就得留够足够的空间，所以这里需要回到在选取上一个物品容量为j - w[i]时的最大值再加上当前物品的价值 dp[i - 1][j - w[i]] + v[i]
        对这两种情况取最大值
     dp[i][j] = max(dp[ i - 1][j], dp[i - 1][j - weight[i]] + value[i])
3. 数组初始化：首先所有位置都写0，然后当遍历到第一个物品的时候，在循环容量j的时候，如果第一个物品能放进去，那么dp[0][j] = 第一个物品的价值
4. 遍历顺序，后面的依赖前面的，所以从前往后
```js
/**
 * 
 * @param {*} v 物品价值的数组
 * @param {*} w 物品重量的数组
 * @param {*} t 背包容量
 */
function npz(v, w, t) {
    const dp = Array(v.length).fill().map(() => Array(t + 1).fill(0))
    console.log(dp)
    for (let j = 0; j <= t; j++) {
        if (j >= w[0]) {
            dp[0][j] = v[0]
        }
    }
    console.log(dp)

    // 外层遍历是遍历物品，要保证物品的索引在物品价值的数组中和重量的数组中都能正确对应
    for (let i = 1; i < v.length; i++) {
        for (let j = 0; j <= t; j++) {
            if (w[i] > j) {
                // 当前物品放不进去 去上一个的最优解
                dp[i][j] = dp[i - 1][j]
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])
            }
        }
    }

    console.log(dp)
    
}
```

# 一维数组解法
为什么可以用一维数组解
在二维数组的解法中，dp[i][j]的值只依赖于上一行的dp[i - 1][...]中的某个值，上一行再往上的值其实都是无用的，也就是说其实我们一直是在覆盖上一行的值，因为我们其实只用一个一维数组就能解决问题
由此可以得出一个结论，像这种dp[i][j]只依赖上一行值的情况，都可以压缩为一维数组
1. dp数组的定义：dp[j]表示的是，当容量为j时，可以放入物品的最大价值
2. 数组初始化：全部初始化为0 即可，
3. 递推公式：分两种情况
    - 放不进去
        dp[j] = dp[j]
    - 放的进去
        - 不放
            dp[j] = dp[j]
        - 放,仍然是比较两种情况的最大值
            dp[j] = max(dp[j], dp[j - w[i]] + v[i])
4. 遍历顺序
    如果还用二维数组的遍历顺序会不会有什么问题呢，现在的dp[j]可能会被更新为dp[j - w[i]],也就是说他会依赖前面的值进行计算，比如当i 为2，在遍历j的时候，如果从前往后遍历，比如当遍历j = 3的时候，当前物品的重量是2，需要取dp[1]的值，但是这个时候dp[1]的值已经本轮i为2的时候计算过了，也就是说i为2的物品已经放进去了，现在还用dp[1]计算的话，相当于把这个物品放了两次，那怎么解决这个问题，既然会用前面的值进行计算，那我们就倒着遍历，就可以避免刚才的问题了，这样的话，取的前面的值仍然是上一轮的计算结果

```js
/**
 * 
 * @param {*} v 物品价值的数组
 * @param {*} w 物品重量的数组
 * @param {*} t 背包容量
 */
function npz(v, w, t) {
    const dp = Array(t + 1).fill(0)
    for (let i = 0; i < v.length; i++) {
        // 这里的跳出条件是当前物品的重量大于j
        // 为什么这里可以这样写，因为如果放不进去 dp[j]的值 不会变化  所以也就不用再计算了
        for (let j = t; j >= w[i]; j--) {
            console.log(dp, i, j, dp[j - w[i]])
            dp[j] = Math.max(dp[j - 1], dp[j - w[i]] + v[i])
        }
    }
    console.log(dp)
    
}
console.log(npz([15, 20, 40], [1, 3, 4], 4))
```

# 示例题 6
给定⼀个只包含正整数的⾮空数组。是否可以将这个数组分割成两个⼦集，使得两个⼦集的元素和相等。
注意:
每个数组中的元素不会超过 100
数组的⼤⼩不会超过 200
示例 1:
输⼊: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
示例 2:
输⼊: [1, 2, 3, 5]
输出: false
## 解题步骤
### 思路
分割成两个子集，是否有一个子集的和是总和的一半，先来个空数组，然后逐个选择元素，看加入或者不加入数组，和是否是sum/2,这其实就可以看出来是01背包问题的变种，容量为sum/2，挑选元素加入，是否可以找出来一个元素总和是sum/2的集合
1. dp数组的定义： dp[i]表示，当总和是i的时候，可以加入的元素的最大值多少
2. 递推公式：可以按照01背包的来
    dp[i] = max(dp[i - 1], dp[i - num[i]] + num[i])
3. 数组的初始化：dp[0] = 0
4. 遍历顺序：按01背包来
```js
function npz(list) {
    const sum = list.reduce((pre, cur) => pre + cur, 0)
    if (sum % 2 !== 0) return false
    const target = sum / 2
    const dp = Array(target + 1).fill(0)
    for (let i = 0; i < list.length; i++) {
        for (let j = target; j >= list[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - list[i]] + list[i])
        }
    }
    console.log(dp)
    return dp[target] === target
}
```

# 示例题 7
有⼀堆⽯头，每块⽯头的重量都是正整数。
每⼀回合，从中选出任意两块⽯头，然后将它们⼀起粉碎。假设⽯头的重量分别为 x 和 y，且 x <= y。那么粉碎的
可能结果如下：
如果 x == y，那么两块⽯头都会被完全粉碎；
如果 x != y，那么重量为 x 的⽯头将会完全粉碎，⽽重量为 y 的⽯头新重量为 y-x。
最后，最多只会剩下⼀块⽯头。返回此⽯头最⼩的可能重量。如果没有⽯头剩下，就返回 0。
示例：
输⼊：[2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值
## 解题思路
从题意可以看出，是需要将这堆石头尽可能的分成重量相等两份，然后看差值，其实就可以演变成重量为总重量一半的背包，最多可以装多少重量的石头，这就还是01背包问题，然后这个一半向下取整，为什么要算向下取整的这一堆，首先为啥要取整，因为可能/2的值不是个整数，然后先算小的这一半，最后用总和减去这一半就是大的另一半，再减去少的这一半就是结果，如果先算多的另一半，最后的计算过程就多了一步。最后分出来之后，剩下的另一半肯定是更多的，相减就是最后一块的重量了
1. dp数组的定义：dp[j] 表示容量为j时最多可装取的重量
2. 递推公式：还是按照01背包的思路
    dp[j] = Math.max(dp[j], dp[j - s[i]] + s[i])
```js
var lastStoneWeightII = function(stones) {
    const total = stones.reduce((total, cur) => total + cur, 0)
    const half = Math.floor(total / 2)
    const dp = Array(half + 1).fill(0)
    for (let i = 0; i < stones.length; i++) {
        for (let j = half; j >= stones[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i])
        }
    }

    return total - dp[half] - dp[half]
};
```
