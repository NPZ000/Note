### 跨域
-  同源策略的限制（协议 IP 端口不一致
1. jsonp
前端事先定义一个回调函数，构造一个script标签，不受同源策略的限制，将回调函数的名字放在请求的query参数中，然后query赋值给script标签的src属性。就会发起请求，然后服务端返回这个回调函数的执行，并且把返回的数据放到回调函数的参数中，返回来之后前端会立即执行这个函数，在函数中拿到返回的数据
缺点：只能发起get请求
安全性问题：csrf攻击 xss攻击

2. cors
跨域资源共享，允许浏览器向跨域服务器发出请求。
前端会自动向请求头添加origin字段，表明请求来源
服务端设置响应头的Access-control-allow-origin

### web 安全
- XSS
跨站脚本攻击，是指在存在漏洞的网站内运行非法的html标签或者js代码
在表单中输入html标签
在url中拼接恶意的js代码，比如页面中有个表单，其中的input的值时从query中取了一个参数的值，我把一段js代码拼接在这个参数的值后面，拿下来之后这段js代码就会执行，可能会窃取cookie，窃取用户信息
常见的
1. 存储型：比如在评论区提交了一段js代码，前端直接给了后端，后端直接存了数据库，然后回显的时候，这段代码就会执行，
防范：前端和后端对用户的输入都进行转义 过滤；设置http only，就无法通过js脚本来读取cookie

- CSRF
跨站请求伪造
1. 受害者登陆a网站，浏览器保留了cookie
2. 引诱受害者登陆b网站
3. 在b网站向a网站发起请求，此时还带着之前留存的cookie，a网站就会以为是用户自己的操作
防范：阻止不明域名的访问
    - 同源检测
        Origin
        referer
    - 利用cookie的samesite
        设置为strict，浏览器就会完全禁止第三方请求携带cookie
    - token
        刚开始，给用户分配一个token，之后请求的时候携带这个token，然后服务器验证这个token

- SQL注入
前端把用户输入的搜索条件传给后端，后端直接拼在了sql查询语句的where字句里面

### https加密流程
1. 客户端向服务器发送client_random，加密方法列表
2. 服务器向客户端返回一个server_random，公钥，加密方法和数字证书，（数字证书是为了证明服务器的身份，防止dns劫持，客户端不知道自己访问的是假的服务器
3. 客户端验证数字证书，再生成一个随机数pre_random并且用公钥加密，发给服务器，
4. 服务器拿到之后用私钥解密，得到这个随机数pre_random
5. 之后双方用client_random,server_random,pre_random生生成一个密钥，之后使用这个密钥用对称加密来进行数据传输

### 输入 URL 到页面展示
- dns解析
浏览器缓存 -> 本机系统缓存 -> 路由器缓存 -> 本地域名服务器
本地dns服务器向根域名服务器请求，根域名服务器返回根的子域也就是顶级域名服务器，本地服务器再向返回的这个顶级域名服务器请求，再返回权威域名服务器，再请求，找到的话就缓存下并返回给客户机
- TCP 连接
    三次握手：
        1. 客户端给服务器发送一个 SYN 报文
        2. 服务器收到 SYN 报文之后，回复一个 SYN + ACK 报文
        3. 客户端收到 SYN+ACK 报文之后，回复一个 ACK 报文
    ** 为什么两次不行 **
    第一次握手：客户端发，服务端接收，服务端可以判定客户端的发送能力和服务端的接受能力是正常的，
    第二次：服务端发，客户端接收，客户端可以知道服务端的接收和发送能力时正常的，客户端的发送和接收能力时正常的，但是现在服务端还不知道客户端的接收能力是正常的（为什么需要第三次的原因
    第三次：客户端发，服务端接收，相当于回应了第二次服务端的消息，现在服务端就知道客户端的接收能力是正常的

    四次挥手：（假设是客户端先发起关闭的请求
    第一次：客户端发送一个 FIN 报文，报文中制定一个序列号值，停止发送数据，进入 FIN_WAIT1 状态,等待服务端的确认
    第二次：服务端接收到 FIN 报文之后，把收到的序列号值加一，然后回复一个 ACK 报文，此时处于 CLOSE_WAIT1 状态
    第三次：如果服务端也想断开链接，就给客户端发一个 FIN 报文，且制定一个序列号值，此时服务端处于 LAST_ACK 状态
    第四次：客户端收到 FIN 之后，把其中序列号值加一 回应一个 ACK 报文，此时客户端处于 TIME_WAIT 状态，需要等一会确保服务端收到自己的 ACK 报文了再进入 CLOSE 状态，如果这个 ACK 丢了，服务端没收到，那么会再次向客户端发一次 FIN 报文，等待客户端回应 ACK
    服务端收到 ACK 报文之后，就关闭链接，进入 CLOSED 状态

- HTTP 请求
*** 浏览器缓存 ***
分为强缓存和协商缓存，首先会看强缓存，没有命中的话再看协商缓存
    - 强缓存
    Expires：http1.0的设置，为服务端返回的数据到期时间，再次请求时的请求时间小于这个值，就判断没有过期，直接使用混存数据
    cache-control: http1.1的设置，如果设置了no-cache,则直接去看协商缓存，如果设置了max-age，表示数据将在这个时间之后失效
    max-age优先于Expires
    - 协商缓存
    浏览器第一次请求数据时，服务端会把缓存标识和数据一起返回个客户端，客户端进行缓存，再次请求时，客户端会把缓存标识发给服务端进行验证，服务端返回304标识资源未修改，可以使用缓存数据
    Last-Modified：服务器响应请求时，会告诉服务端数据最后修改的时间
    if-modified-Since：客户端再次请求时，请求头会包含次字段，值为缓存中获得的最后修改时间，服务端收到之后，会拿这个值和资源的最后修改时间进行对比，一致的话返回304

    Etag: 服务器响应请求时，返回给客户端的资源的唯一标识
    If-None-Match:携带Etag的值，服务端判断请求的数据的Etag值是否与其匹配，如果相同说明未被修改过，返回304，反之返回200和新的数据（优先于if-modified-since

ps: 地址栏中写入URL，会去走强缓存和协商缓存，
    f5刷新，会跳过强缓存，检查协商缓存
    Ctrl-F5 会删除之前的缓存结果，重新请求资源
*** HTTP Request Header ***
方法名 请求地址 协议
主机名
UA：用户的操作系统 浏览器等信息
Accept：浏览器期望得到的资源的类型
origin / referer： 标明来源
Connection： keep-live保持长链接
cache-control/If-modified-Since/If-Noce-Match: 缓存
content-type：发送数据的类型
cookie

*** HTTP Reponse Header ***
状态码
Date： 时间
Etag / Last-modified ：缓存相关
set-cookie
content-type：返回的数据类型

*** HTTP Status Code ***
301 永久重定向
302 临时重定向
304 资源未修改
400 请求体有语法错误
401 需要用户验证
403 服务器拒绝请求
404 请求的资源没有找到
500 服务器内部错误

- 浏览器收到响应数据，解析报文，开始渲染页面
*** 浏览器 ***
最新的浏览器多进程架构
    - 浏览器进程：负责页面显示，用户交互，子进程管理等
    - 渲染进程： 解析 html css js 并渲染页面，每个页面都会开一个渲染进程
    - GPU 进程： 渲染 3D 动画的
    - 网络进程： 负责页面的网络资源加载
    - 插件进程
-- 渲染进程 --
1. GUI 渲染线程
解析 HTML CSS，构建 DOM 树和 Render 树，布局和绘制等
当页面发生重排 or 重绘时，该线程就会执行
2. JS 引擎线程
处理 JS 代码
3. 事件触发线程
用来控制事件循环，协助 JS 引擎处理事件
4. 定时器线程
定时器所在的线程
5. 异步 http 请求线程
处理http 请求
ps: js 引擎线程和 GUI 线程互斥，因为 js 是可以操作 dom 的
*** 浏览器渲染页面流程 ***
1. 解析 html 构建 dom 树
2. 解析 css 生成样式表
3. 结合样式表和 dom 树生成render树
4. 根据 render 树开始布局，确定元素的尺寸 位置
5. 生成图层 绘制图层
6. 最后将图层发送到 GPU ，进行合成，并显示在屏幕上

### Cookie
HTTP 是无状态的协议，每个请求都是独立的，服务端不知道客户端的信息，也不知道两次请求的发送者是不是同一个人，cookie 就是用来解决这个问题，每次请求的时候带上cookie让服务端知道是谁请求的它；存储在客户端，不可跨域。
name=value:要保存的数据
domain：所属的域名
path： 在哪个路径下生效
maxAge： 失效的时间
expires： 过期的时间
httponly： 是否可以被js读取
ps： 如果没有设置时效，就会在客户端关闭的时候被清除

### session
存储在服务端，生成一个sessionId返回客户端，客户端把它放在cookie，之后请求的时候携带，服务端拿到之后查找对应的session信息，来验证用户的身份

### cookie 和 session 的区别
cookie存在客户端，session放在服务器，
cookie只能存字符串数据，session无限制
cookie可以设置长时间保持，session时间短，客户端关闭或者session超时都会失效
存储大小不同：cookie只能4k session无限制

### token
用户登陆之后，信息发给服务端，服务端对信息进行加密得到一个token返回给客户端，客户端之后请求的时候携带在header中，服务端拿到之后进行解密然后进行认证，
- refersh token用于在token失效时候，重新生成token

## http1 和 http2 的区别
http1 对同一个域名有6个连接的限制，http2 基于多路复用的技术解决了这个问题，http1传输的是文本，http2传输的是二进制文件
http2:
多路复用：帧-数据被拆分成了帧，帧是数据的最小单位，帧可以乱序发送，帧中携带了序列号，接收方收到之后可以根据序列号重新进行组装，流-信息传输的通道，帧都是在流中传输的，所有的流都是在一个 tcp 连接里，流可以并行传输
服务端推送：服务端可以主动向客户端发送消息了，比如html文件。css文件等可以不必等客户端请求就直接主动发送给客户端
头部压缩：在http1中，每次请求都要携带请求头，在http2中，客户端和服务端建立了一张首部表，存放首部的信息，双方一起维护，每次请求只发送新增的和有修改的信息，对于相同的信息不再发送

## GET 和 POST 的区别
1. GET 会被缓存，留下历史记录， POST 不会
2. GET 只能进行 URL 编码，只能接受 ASCII 字符，POST 无限制
3. GET 的参数放在 URL 上
4. GET 发一个 TCP 的数据包， POST 会发两个，先发 header 再发 body

## 跨域
同源策略：协议、域名、端口必须都相同，否则即为跨域
- cors
浏览器将请求分为简单请求和复杂请求，
1. 对于简单请求，浏览器采取先请求再判断的方式，即浏览器直接发出 cors 请求，在请求头中增加 origin 字段 origin: http://127.0.0.1 , 告诉服务器自己来自哪个源（协议+域名+端口），如果服务端返回的 response headers 包含Access-control-Aloww-Origin 字段，则说明这个 origin 是服务器允许的范围，它的值要么是请求时 origin 的值，要么是 * ，表示允许所有人访问，如果没有，则表示服务器不允许跨域访问，浏览器就会抛出错误
2. 对于复杂请求，浏览器会先发一个预检请求，以 OPTION 的格式，用于询问服务器是否支持跨域请求，同样的在请求头中会增加 origin 字段，然后服务器响应之后，浏览器会拿请求时的 origin 和返回的 Access-Control-Aloww-Origin 做比较，如果不一致，浏览器就会报错，





