## webpack 的打包流程
1. 从配置文件和shell 命令中得到配置参数
2. 根据配置参数初始化 compile 对象，加载所有配置的插件，开始编译
3. 从入口文件开始，调用所有loader 对文件进行编译，再找出文件依赖的文件，重复这个动作，得到所有编译后的文件和他们的依赖关系
4. 根据依赖关系将所有文件打包成一个个 chuck，接着就加到输出列表中
5. 根据配置中的output 确定输出的位置和文件名，最后将要输出的内容写入进去

## rollup 的编译
rollup 基于浏览器原生支持的 esm ，不同于 webpack 不需要提前进行打包，而是先把开发服务器启动起来，然后加载入口文件，遇到 type 为 module 的 script 标签，再去加载模块，实现了按需加载，利用 http 缓存对依赖模块进行强缓存，进一步加快页面的加载速度

#### webpack 热更新原理
1. 建立通信通道，webpack devServer启动后，会和浏览器通过websocket建立双向通信，
2. 当代码修改之后，webpack会重新编译代码，并通知浏览器
3. 浏览器重新请求修改之后的文件
4. 用新代码替换旧代码，并触发重新渲染

### vite的热更新
1. 监听文件变化
2. 通过websocket通知浏览器哪个模块需要更新
3. 浏览器请求需要替换的新模块，然后用新模块代替旧模块，并触发重新传染

### tree shaking
因为 esm 的导入都是静态的，所有的export 和import 都是在顶级声明的，且不允许写在比如 if 语句里面，所以依赖关系在编译阶段就可以确定了，从而可以判断出哪些export 出来的模块并没有 import ，然后被 import 的模块，再通过分析 AST 语法树，判断是否被用到了

## vite的dev server为什么比webpack的快
webpack每次在启动和刷新的时候每次都得打包全部代码再生成bundle，耗时就比较成
vite凭借浏览器原生支持es moudle的特性，按需编译代码，无需重新打包，对于第三方依赖，会在预构建过程中将其转为es模块，并缓存，之后直接复用缓存，在热更新的时候只需要替换单个文件 

## vite预构建解决的问题
1. 将第三方依赖的commonjs转换为es 模块，确保他们能被浏览器直接加载
2. 依赖内部的模块化分割，有些依赖内部会有很多小模块，会造成大量请求，预构建将他们合并为一个js文件，只需要发一次请求
3. 依赖路径解析，确保浏览器可以加载依赖的模块
4. 将第三方依赖缓存，之后直接复用，

