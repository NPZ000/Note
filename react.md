### 虚拟dom
react和vue都采用了这样的机制，其实现原理是将真实dom映射成为一个js对象，当页面上的元素发生变化，先不去直接操作dom，而是创建一个新的js对象，也就是一个新的虚拟dom树，对新旧两个树进行diff，明确需要进行更新的元素，将更新的范围尽量缩小，然后再去映射到真实的dom，这样可以减少操作dom的次数，从而来提高性能，同时，因为开发者只需要关心如何去更新虚拟dom树的js对象，可以使用相关的API，相比较最原始的直接操作dom的开发方式大大提高了开发效率。
关于优化策略，在上述流程中，最复杂的点是新旧dom树的diff过程，所以可以从这个点来考虑，如何尽可能的加快或者简化diff流程，比如改进diff算法，对静态节点进行标记从而在diff过程中跳过等
### key 的作用
每当一个列表重新渲染时，react 会根据每一项列表元素的 key 来检索上一次渲染时与每个 key 所匹配的元素，如果发现当前的列表有一个之前不存在的 key，那么就会创建出一个新组件，如果 react 发现和之前对比少了一个 key，那么就会销毁之前对应的组件，如果一个组件的 key 发生了变化，那么这个元素就会被销毁，然后是用新的数据重新创建一份

### vue 和 react 的区别
1. 都推崇组件化的开发理念
2. 写法上的不同，vue 是html 和 js 分离，也就是结构和行为分离，对html提供一些扩展的属性 比如 v-if v-model；react 则是使用了 jsx 的写法，在一个函数返回一个元素，看起来就是把html和js混在了一起
3. 内部数据管理，vue使用data 方法返回了一个对象，对象中的数据可以直接改变，改变后会引起view 的变化，也就是vue 的数据双向绑定，在vue2的实现中是通过，object。defineProperty对对象属性的set进行劫持，以此来监听数据的变化，在vue3 的实现中是通过proxy代理来实现这里效果。react的数据，在class组件中，是在构造函数中放在了state里面，数据的改变只能通过setState来操作。setState才会引起view 的变化，在function组件中，通过使用hook ，useState对数据进行给管理，他返回一个value和设置value的方法，改变value之后view会更新
4. 父子组件通信，都是单向数据流，通过props向下传递，子于父的通信略有不同，vue是通过父组件监听子组件的自定义方法，子组件去emit这个方法，并传入数据，父组件可以接收到这个数据。react 是通过props传递一个回调，子组件去调用这个回调并传入数据这样。
5. 关于diff，整体的思路差不多，都是通过diff一个dom树，只进行同级的diff，如果不同则直接销毁，然后创建新的组件，在具体的diff算法上略有不同，vue会进行一个双向的遍历，会取新列表的头和尾和旧列表的头和尾，进行俩俩对比，然后判断是否要移动，diff完之后，新列表多出来的元素会找到对应的位置插进去，旧列表多出来的会删除。而react是直接遍历新列表，然后去old list中查找，没找到就新增，找到了再判断要怎么移动，最后旧列表中多出来的删除
6. 数据可变性：react 推崇数据不可变，只能通过setState来触发视图的更新，而 vue 的数据是可变的，可直接改变数据，通过它的响应式系统来触发视图的更新

### useCallback & useMemo 区别
都是用来缓存的
前者缓存的是一个回调函数，使用场景：父组件更新时通过props传给子组件的函数也会重新创建，使用useCallback缓存的话，就不用每次都重新创建
后者缓存的是一个值，也可以是一个回函数计算之后返回的值，当依赖项发生改变时才会重新计算值这个值

### react 的fiber
首先说一下，为什么引入fiber架构，因为之前的架构在渲染dom的时候，是一气呵成的，一旦开始不能中断，如果dom很多的话，就会造成长时间占用主线程，导致帧率下降，页面卡顿等问题，所以引入了新的fiber架构，旧的架构不能中断是因为是一个递归栈结构，而fiber改成了链表机构，就解决了不可中断的问题，通过利用requestidlecallback只在浏览器空余的时间执行任务，也就是常说的时间分片，同时还对不同的任务标注了不同的优先级，低优先级的任务可以被高优先级的任务打断，用户输入的优先级大于渲染的优先级

### memo 的第二个参数
memo 允许组件在props不改变的情况下不更新组件，默认会对props进行浅比较，也可以传入一个自定义比较函数作为第二个参数，比较函数返回true不更新组件，返回false则更新组件
## 使用场景
某个组件内容单一，明确不需要跟着父组件更新，可以固定的第二个参数返回true

### useEffect 模拟生命周期
第二个参数传入[], 只会在挂载的时候执行一次
第二个参数传入[dependency], 会在挂载和依赖项更新的时候执行
第二个参数不传，则每次组件更新都会执行，容易造成死循环，比如在其中执行了setState